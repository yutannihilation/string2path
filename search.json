[{"path":"/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2020 Hiroaki Yutani Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Hiroaki Yutani. Author, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Yutani H (2022). string2path: Rendering Font 'data.frame'. https://yutannihilation.github.io/string2path/, https://github.com/yutannihilation/string2path.","code":"@Manual{,   title = {string2path: Rendering Font into 'data.frame'},   author = {Hiroaki Yutani},   year = {2022},   note = {https://yutannihilation.github.io/string2path/, https://github.com/yutannihilation/string2path}, }"},{"path":"/index.html","id":"string2path","dir":"","previous_headings":"","what":"Rendering Font into data.frame","title":"Rendering Font into data.frame","text":"string2path R package converts text paths outlines glyph, based font data. hood, package powered extendr framework use two Rust crates: ttf-parser parsing font data. TrueType font (.ttf) OpenType font (.otf) supported. lyon tessellation polygons flattening curves.","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Rendering Font into data.frame","text":"using Windows, lucky. repository provides pre-compiled binary , don’t need install Rust toolchain. Otherwise, need Rust toolchain installed trying install package. See https://www.rust-lang.org/tools/install installation instructions.","code":"install.packages(\"string2path\")  # Or the development version from GitHub: # install.packages(\"devtools\") devtools::install_github(\"yutannihilation/string2path\")"},{"path":[]},{"path":"/index.html","id":"string2path-1","dir":"","previous_headings":"Example","what":"string2path()","title":"Rendering Font into data.frame","text":"","code":"library(string2path) library(ggplot2)  # You can change the font family to the available one on your machine. # Try dump_fontdb() to list the font faces that string2path can recognize. d <- string2path(\"カラテが\\n高まる。\", \"Noto Sans JP\", font_weight = \"bold\")  d <- tibble::rowid_to_column(d)  ggplot(d) +   geom_path(aes(x, y, group = path_id, colour = factor(glyph_id)), linewidth = 1.5) +   theme_minimal() +   coord_equal() +   theme(legend.position = \"top\") +   scale_colour_viridis_d(option = \"H\") library(gganimate) d <- string2path(\"蹴\", \"Noto Sans JP\") d <- tibble::rowid_to_column(d)  ggplot(d) +   geom_path(aes(x, y, group = path_id), size = 2, colour = \"purple2\", lineend = \"round\") +   theme_minimal() +   coord_equal() +   transition_reveal(rowid) #> size aesthetic has been deprecated for use with lines as of ggplot2 3.4.0 #> ℹ Please use linewidth aesthetic instead #> This message is displayed once every 8 hours."},{"path":"/index.html","id":"string2fill","dir":"","previous_headings":"Example","what":"string2fill()","title":"Rendering Font into data.frame","text":"","code":"d <- string2fill(\"abc\", \"Iosevka SS08\", font_weight = \"bold\", font_style = \"italic\")  ggplot(d) +   geom_polygon(aes(x, y, group = triangle_id, fill = factor(triangle_id %% 7)),                colour = \"grey\", linewidth = 0.1) +   theme_minimal() +   coord_equal() +   theme(legend.position = \"none\") +   scale_fill_viridis_d(option = \"H\")"},{"path":"/index.html","id":"string2stroke","dir":"","previous_headings":"Example","what":"string2stroke()","title":"Rendering Font into data.frame","text":"","code":"for (w in 1:9 * 0.01) {   d <- string2stroke(\"abc\",\"Iosevka SS08\", font_weight = \"bold\", font_style = \"italic\", line_width = w)      p <- ggplot(d) +     geom_polygon(aes(x, y, group = triangle_id, fill = factor(triangle_id %% 2)),                  colour = \"grey\", linewidth = 0.1) +     theme_minimal() +     coord_equal() +     theme(legend.position = \"none\") +     scale_fill_manual(values = c(\"purple\", \"pink\"))   plot(p) }"},{"path":"/index.html","id":"tolerance","dir":"","previous_headings":"","what":"tolerance","title":"Rendering Font into data.frame","text":"tolerance controls resolution tessellation. can reduce tolerance get higher resolutions.  Note tolerance parameter behaves bit differently string2fill() string2stroke(). , either case, 1e-5 ~ 1e-6 enough.","code":"for (tolerance in c(1e-1, 1e-2, 1e-3, 1e-4, 1e-5, 1e-6, 1e-7)) {   d <- string2fill(\"abc\", \"Iosevka SS08\", font_weight = \"bold\", font_style = \"italic\", tolerance = tolerance)      p <- ggplot(d) +     geom_polygon(aes(x, y, group = triangle_id),                  fill = \"transparent\", colour = \"black\", linewidth = 0.5) +     theme_minimal() +     coord_equal() +     ggtitle(paste0(\"tolerance: \", tolerance))   plot(p) } for (tolerance in c(1e-1, 1e-2, 1e-3, 1e-4, 1e-5, 1e-6, 1e-7)) {   d <- string2path(\"abc\", \"Iosevka SS08\", font_weight = \"bold\", font_style = \"italic\", tolerance = tolerance)      p <- ggplot(d) +     geom_path(aes(x, y, group = path_id), colour = \"black\", size = 0.5) +     geom_point(aes(x, y, group = path_id), colour = \"black\", size = 1.5) +     theme_minimal() +     coord_equal() +     ggtitle(paste0(\"tolerance: \", tolerance))   plot(p) }"},{"path":"/reference/dump_fontdb.html","id":null,"dir":"Reference","previous_headings":"","what":"Dump the Font Database — dump_fontdb","title":"Dump the Font Database — dump_fontdb","text":"debugging purposes, extract font faces font database 'string2path' uses internally.","code":""},{"path":"/reference/dump_fontdb.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Dump the Font Database — dump_fontdb","text":"","code":"dump_fontdb()"},{"path":"/reference/dump_fontdb.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Dump the Font Database — dump_fontdb","text":"tibble() containing columns: source source file font face. index index font face within source. family font family face. weight weight face. style style face.","code":""},{"path":"/reference/string2path.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert a String to Paths — string2path","title":"Convert a String to Paths — string2path","text":"string2path() converts text paths width-less outlines glyph. string2stroke() converts text paths outlines, specified line width, glyph. string2fill() converts text paths filled polygon glyph.","code":""},{"path":"/reference/string2path.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert a String to Paths — string2path","text":"","code":"string2path(   text,   font_family,   font_weight = c(\"normal\", \"thin\", \"extra_thin\", \"light\", \"medium\", \"semibold\",     \"bold\", \"extra_bold\", \"black\"),   font_style = c(\"normal\", \"italic\", \"oblique\"),   tolerance = 5e-05 )  string2stroke(   text,   font_family,   font_weight = c(\"normal\", \"thin\", \"extra_thin\", \"light\", \"medium\", \"semibold\",     \"bold\", \"extra_bold\", \"black\"),   font_style = c(\"normal\", \"italic\", \"oblique\"),   tolerance = 5e-05,   line_width = 0.03 )  string2fill(   text,   font_family,   font_weight = c(\"normal\", \"thin\", \"extra_thin\", \"light\", \"medium\", \"semibold\",     \"bold\", \"extra_bold\", \"black\"),   font_style = c(\"normal\", \"italic\", \"oblique\"),   tolerance = 5e-05 )"},{"path":"/reference/string2path.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert a String to Paths — string2path","text":"text text convert paths. font_family font family. font_weight font weight. font_style font style. tolerance Maximum distance allowed curve approximation. details, please refer documentation underlying Rust library. line_width Line width strokes.","code":""},{"path":"/reference/string2path.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert a String to Paths — string2path","text":"tibble() containing columns: x x position point path, scaled x / line height. left side first glyph x = 0. y Y position point path, scaled y / line height. baseline first line y = 0. glyph_id IDs distinguish glyphs. path_id IDs distinguish groups paths. triangle_id IDs distinguish triangles. string2path() contain column.","code":""},{"path":"/reference/string2path.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert a String to Paths — string2path","text":"","code":"available_fonts <- dump_fontdb()  if (nrow(available_fonts) > 0) {   family <- available_fonts$family[1]   weight <- available_fonts$weight[1]   style  <- available_fonts$style[1]    # string2path() converts a text to paths   d_path <- string2path(\"TEXT\", family, weight, style)   plot(d_path$x, d_path$y)   for (p in split(d_path, d_path$path_id)) {     lines(p$x, p$y)   }    # string2stroke() converts a text to strokes   d_stroke <- string2stroke(\"TEXT\", family, weight, style)   plot(d_stroke$x, d_stroke$y)    # The stroke is split into triangles, which can be distinguished by `triangle_id`   set.seed(2)   for (p in split(d_stroke, d_stroke$triangle_id)) {     polygon(p$x, p$y, col = rgb(runif(1), runif(1), runif(1), 0.8))   }    # string2fill() converts a text to filled polygons   d_fill <- string2fill(\"TEXT\", family, weight, style)   plot(d_fill$x, d_fill$y)    # The polygon is split into triangles, which can be distinguished by `triangle_id`   set.seed(2)   for (p in split(d_fill, d_fill$triangle_id)) {     polygon(p$x, p$y, col = rgb(runif(1), runif(1), runif(1), 0.8))   } }"},{"path":[]},{"path":"/news/index.html","id":"breaking-changes-development-version","dir":"Changelog","previous_headings":"","what":"Breaking changes","title":"string2path (development version)","text":"Now functions accepts font family name instead path actual font file. support TTC file properly, contains one fonts. new function dump_fontdb() useful check actual family name (weight style) specify. minimum supported Rust version bumped 1.56.0 2021 edition.","code":""},{"path":"/news/index.html","id":"string2path-004","dir":"Changelog","previous_headings":"","what":"string2path 0.0.4","title":"string2path 0.0.4","text":"CRAN release: 2021-11-22 maintenance release make installation work even slow internet connection.","code":""},{"path":"/news/index.html","id":"string2path-003","dir":"Changelog","previous_headings":"","what":"string2path 0.0.3","title":"string2path 0.0.3","text":"CRAN release: 2021-09-26 maintenance release improve configure scripts detect Rust installations correctly. new features added.","code":""},{"path":"/news/index.html","id":"string2path-002","dir":"Changelog","previous_headings":"","what":"string2path 0.0.2","title":"string2path 0.0.2","text":"CRAN release: 2021-08-09 Fix CRAN build errors. Support “open path”-type glyphs (#7).","code":""},{"path":"/news/index.html","id":"string2path-001","dir":"Changelog","previous_headings":"","what":"string2path 0.0.1","title":"string2path 0.0.1","text":"CRAN release: 2021-08-04 Added NEWS.md file track changes package.","code":""}]
